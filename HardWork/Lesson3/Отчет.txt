На текущий момент не удалось на работе найти подходящий код. Причин несколько: 
1. Сейчас подвергается рефакторингу текущий код, написанный мною ранее
2. TDD не применимо в принципе в рабочих задачах по причине того, что программа должна взаимодействовать с железом: в этом случае разработать тесты крайне сложно и неоправданно. 
Также мой домашний проект - медиа-проигрыватель не подходит к заданию по тем же причинам. 
В связи с вышеизложенным, мною было принято решение придумать задачу с требуемыми параметрами и решить ее. Был задан следующий запрос в gpt: "Предложи задачу для отработки TDD, решение которой будет занимать 150-200 строк кода". 
Таким образом, исходная задача выглядит так:
Задача: "Менеджер задач с фильтрацией и сортировкой"

Описание:
Реализовать класс TaskManager, который управляет списком задач. Задача имеет следующие свойства:

    Название задачи (строка)
    Приоритет (целое число, 1 — высокий, 2 — средний, 3 — низкий)
    Статус (завершена или нет)
    Дедлайн (дата в формате YYYY-MM-DD)

Класс должен предоставлять функционал для:

    Добавления задачи.
    Удаления задачи по названию.
    Пометки задачи как завершенной.
    Фильтрации задач по статусу (завершенные/незавершенные).
    Сортировки задач по одному из полей (например, по имени или дедлайну).
        
1. Начал разработку с написания тестов, отражающий функционал класса.
На данном этапе расписал тесты для всех нужных методов класса и начал по одному реализовывать тесты. Написал первый тест для метода addTask (добавляет новую задачу). На этом этапе пришлось "зафрендить" класс тестировщика к основному классу, что нарушало принцип инкапсуляции, но другого способа проверить, что задача добавилась - я не нашел. Далее я начал реализовывать сам метод и сразу заметил, что функционал делается таким образом, чтобы соответствовать тесту, то есть не возникают мыслей о каких-то исключительных ситуаций. Делается код, чтобы пройти тест. И если он пройдет - мысленно успокаиваешься и не думаешь о нестандартных и неучтенных ситуациях. К тому же, всегда происходит подгонка теста под конкретную реализацию метода. То есть реализация и тесты идут друг за другом. Получается, что если в голову не пришли какие-то особенные ситуации, то они так и не будут учтены ни в коде, ни в тестах и программа может упасть при совпадении каких-то факторов.
Также возник вопрос о том, что делать с задачами с одинаковым именем и разной датой.
Таким образом, уже на данном этапе возникли проблемы, которые могут добавить проблемы в будущем. 
Далее я реализовал оставшиеся методы по аналогичному принципу.
Изучил материалы "Три уровня рассуждений о программной системе". Понял, что нужно для начала спроектировать дизайн или логическую архитектуру данного класса.
Дизайн:
1. Задачи должны добавляться и храниться по порядку (то есть по дате добавления).
2. При совпадении имен нужно дублировать задачи (т.к. дата добавления разная и это могут быть разные задачи). 
3. Удаление задач с одинаковым именем должно удалять более старую задачу.
4. Фильтрование по статусу не должно изменять исходный контейнер, а должно создавать новый. Если нужных задач не нашлось, то новый контейнер должен быть пустым.
5. Сортировка по полю должна принимать 2 поля: приоритет и имя задачи. Сортировать нужно по возрастанию (по алфавиту). Изменяться должен исходный контейнер, новый не создавать.

Пример кода:
Было:
```
void TaskManager::addTask(const std::string &name, uint8_t priority, const std::string &deadline)
{
    Task task;
    task.taskName = name;
    task.priority = priority;
    task.deadLine = deadline;
    task.status = false;
    m_tasks.push_back(task);
}
```
Стало:
Поскольку задачи должны храниться по порядку, решил добавлять элементы в начало контейнера. 
```
void TaskManager::addTask(const std::string &name, uint8_t priority, const std::string &deadline)
{
    Task task;
    task.taskName = name;
    task.priority = priority;
    task.deadLine = deadline;
    task.status = false;
    
    m_tasks.insert(m_tasks.begin(), task);
}
```
Также аналогично пришлось изменить тесты
Было:
```
    void test_addTask() {
        m_taskManager.addTask("clean room", 1, "18.06.2024");
        auto task1 = m_taskManager.m_tasks.at(0);
        bool firstTest = task1.taskName == "clean room" &&
                         task1.priority == 1 &&
                         task1.status == false &&
                         task1.deadLine == "18.06.2024" &&
                         m_taskManager.m_tasks.size() == 1;

        m_taskManager.addTask("run", 2, "20.06.2024");
        auto task2 = m_taskManager.m_tasks.at(1);
        bool secondTest = task2.taskName == "run" &&
                          task2.priority == 2 &&
                          task2.status == false &&
                          task2.deadLine == "20.06.2024" &&
                          m_taskManager.m_tasks.size() == 2;
        if(firstTest) {
            std::cout << "_add_ Test 1 passed" << std::endl;
        } else {
            std::cout << "_add_ Test 1 error" << std::endl;
        }
        if(secondTest) {
            std::cout << "_add_ Test 2 passed" << std::endl;
        } else {
            std::cout << "_add_ Test 2 error" << std::endl;
        }

        m_taskManager.m_tasks.clear();
    };
```
Стало:
```
void TaskManager::addTask(const std::string &name, uint8_t priority, const std::string &deadline)
{
    Task task;
    task.taskName = name;
    task.priority = priority;
    task.deadLine = deadline;
    task.status = false;
    
    m_tasks.insert(m_tasks.begin(), task);
}
```


Итог. Разработка кода по TDD сначала мне показалось идеальной. Я решил, что смогу четко описать поведение программы и учесть все граничные случаи в тестах, а потом всего лишь останется сделать реализацию этого. Но все оказалось совсем не так. Большую часть граничных случаев я или не учел, или подогнал тесты так, чтобы они учитывали это. Из-за такого подхода код получался несвязным и имел много лишнего. Для себя я понял, что необходимо продумывать и расписывать ТЗ (или дизайн или логическую архитектуру) до реализации кода. Тогда и тесты и код будут следовать дизайну, а не друг другу.
