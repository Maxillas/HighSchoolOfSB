
1. Итого значение может быть невереным по следующим причинам: происходит увеличение одного и того же ресурса сразу всеми потоками, 
таким образом один поток может принять не 0 (как было изначально), а например 7 (после частичного увеличения в другом потоке) и так для каждого.
Либо же два потока могут одновременно увеличить исходное число и тем самым пропустят одну итерацию инкремента.
Решение: использовать атомарную операцию

std::atomic<int> counter{0};  // Атомарный счётчик

void incrementCounter() {
    for (int j = 0; j < 100000; j++) {
        counter++;  // Атомарный инкремент
    }
}

2. Ошибка заключается в следующем: Thread 1 захватывает lock1 и пытается захватить lock2. 
Thread 2 захватывает lock2 и пытается захватить lock1. Оба потока бесконечно ждут друг друга, потому что каждый держит один ресурс и не отпускает его.
Для решения проблемы используем мьютексы и порядок и захвата:

std::mutex lock1;
std::mutex lock2;

void thread1() {
    std::lock(lock1, lock2);  // Захватываем оба мьютекса атомарно
    std::lock_guard<std::mutex> guard1(lock1, std::adopt_lock);  // Управляем освобождением
    std::lock_guard<std::mutex> guard2(lock2, std::adopt_lock);

    std::cout << "Thread 1 acquired lock1 and lock2" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
}

void thread2() {
    std::lock(lock1, lock2);
    std::lock_guard<std::mutex> guard1(lock1, std::adopt_lock);
    std::lock_guard<std::mutex> guard2(lock2, std::adopt_lock);

    std::cout << "Thread 2 acquired lock1 and lock2" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
}
